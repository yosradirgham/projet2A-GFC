//--------------------------------------
//--- 010 Editor v5.0 Binary Template
//
// File:  DotNetTemplate.bt
// Author:  Fabrice Sabatier fabrice.sabatier@loria.fr
// Revision: 0.0.0.1
// Purpose:  Parsing dotnet PE file
// Build:    2017.12.14
// Thanks: xSpy [cdutboy@gmail.com], Joe Kirwin https://github.com/joekir
// Doc refs: http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf
//--------------------------------------

typedef QWORD ULONGLONG;    //fix ULONGLONG

typedef struct _IMAGE_DOS_HEADER
{  
    WORD   e_magic      <format=hex,comment="IMAGE_DOS_SIGNATURE = 0x5A4D">;    
    WORD   e_cblp       <comment="Bytes on last page of file">;
    WORD   e_cp         <comment="Pages in file">;
    WORD   e_crlc       <comment="Relocations">;
    WORD   e_cparhdr    <comment="Size of header in paragraphs">;
    WORD   e_minalloc   <comment="Minimum extra paragraphs needed">;
    WORD   e_maxalloc   <comment="Maximum extra paragraphs needed">;
    WORD   e_ss         <comment="Initial (relative) SS value">;
    WORD   e_sp         <comment="Initial SP value">;
    WORD   e_csum       <comment="Checksum">;
    WORD   e_ip         <comment="Initial IP value">;
    WORD   e_cs         <comment="Initial (relative) CS value">;
    WORD   e_lfarlc     <comment="File address of relocation table">;
    WORD   e_ovno       <comment="Overlay number">;
    WORD   e_res[4]     <comment="Reserved words">;
    WORD   e_oemid      <comment="OEM identifier (for e_oeminfo)">;
    WORD   e_oeminfo    <comment="OEM information; e_oemid specific">; 
    WORD   e_res2[10]   <comment="Reserved words">;
    LONG   e_lfanew     <fgcolor=cPurple,format=hex,comment="NtHeader Offset">;
} IMAGE_DOS_HEADER;

typedef enum<WORD> _IMAGE_MACHINE
{
    IMAGE_MACHINE_UNKNOWN  = 0,
    I386     = 0x014c,
    R3000    = 0x0162,  // MIPS little-endian, 0x160 big-endian
    R4000    = 0x0166,  // MIPS little-endian
    R10000   = 0x0168,  // MIPS little-endian
    WCEMIPSV2= 0x0169,  // MIPS little-endian WCE v2
    ALPHA    = 0x0184,  // Alpha_AXP
    SH3      = 0x01a2,  // SH3 little-endian
    SH3DSP   = 0x01a3,
    SH3E     = 0x01a4,  // SH3E little-endian
    SH4      = 0x01a6,  // SH4 little-endian
    SH5      = 0x01a8,  // SH5
    ARM      = 0x01c0,  // ARM Little-Endian
    THUMB    = 0x01c2,
    AM33     = 0x01d3,
    POWERPC  = 0x01F0,  // IBM PowerPC Little-Endian
    POWERPCFP= 0x01f1,
    IA64     = 0x0200,  // Intel 64
    MIPS16   = 0x0266,  // MIPS
    ALPHA64  = 0x0284,  // ALPHA64
    MIPSFPU  = 0x0366,  // MIPS
    MIPSFPU16= 0x0466,  // MIPS
    TRICORE  = 0x0520,  // Infineon
    CEF      = 0x0CEF,
    EBC      = 0x0EBC,  // EFI Byte Code
    AMD64    = 0x8664,  // AMD64 (K8)
    M32R     = 0x9041,  // M32R little-endian
    CEE      = 0xC0EE
}IMAGE_MACHINE <comment="WORD">;

//Characteristics
typedef struct _FILE_CHARACTERISTICS
{
    WORD IMAGE_FILE_RELOCS_STRIPPED:1           <comment="0x0001  Relocation info stripped from file">;
    WORD IMAGE_FILE_EXECUTABLE_IMAGE:1          <comment="0x0002  File is executable">;
    WORD IMAGE_FILE_LINE_NUMS_STRIPPED:1        <comment="0x0004  Line nunbers stripped from file">;
    WORD IMAGE_FILE_LOCAL_SYMS_STRIPPED:1       <comment="0x0008  Local symbols stripped from file">;
    WORD IMAGE_FILE_AGGRESIVE_WS_TRIM:1         <comment="0x0010  Agressively trim working set">;
    WORD IMAGE_FILE_LARGE_ADDRESS_AWARE:1       <comment="0x0020  App can handle >2gb addresses">;
    WORD                               :1       <comment="0x0040  Reserved",hidden=true>;
    WORD IMAGE_FILE_BYTES_REVERSED_LO:1         <comment="0x0080  Bytes of machine word are reversed">;
    WORD IMAGE_FILE_32BIT_MACHINE:1             <comment="0x0100  32 bit word machine">;
    WORD IMAGE_FILE_DEBUG_STRIPPED:1            <comment="0x0200  Debugging info stripped from file in .DBG file">;
    WORD IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP:1   <comment="0x0400  If Image is on removable media, copy and run from the swap file">;
    WORD IMAGE_FILE_NET_RUN_FROM_SWAP:1         <comment="0x0800  If Image is on Net, copy and run from the swap file">;
    WORD IMAGE_FILE_SYSTEM:1                    <comment="0x1000  System File">;
    WORD IMAGE_FILE_DLL:1                       <comment="0x2000  File is a DLL">;
    WORD IMAGE_FILE_UP_SYSTEM_ONLY:1            <comment="0x4000  File should only be run on a UP machine">;
    WORD IMAGE_FILE_BYTES_REVERSED_HI:1         <comment="0x8000  Bytes of machine word are reversed">;
}FILE_CHARACTERISTICS <comment="WORD">;

typedef struct _IMAGE_FILE_HEADER
{
    IMAGE_MACHINE    Machine                    <fgcolor=cPurple,format=hex,comment="WORD">;
    WORD    NumberOfSections                    <fgcolor=cBlue,comment="Section num">;
    time_t  TimeDateStamp                       <format=hex,comment="DWORD,from 01/01/1970 12:00 AM">;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    FILE_CHARACTERISTICS   Characteristics      <comment="WORD">;
}IMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY
{
    DWORD   VirtualAddress  <format=hex,comment=CommentRVA2FOA>;
    DWORD   Size;
}IMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_DATA_DIRECTORY_ARRAY
{
    IMAGE_DATA_DIRECTORY    DataDir0    <comment="IMAGE_DIRECTORY_ENTRY_EXPORT">;
    IMAGE_DATA_DIRECTORY    DataDir1    <fgcolor=cPurple,comment="IMAGE_DIRECTORY_ENTRY_IMPORT">;
    IMAGE_DATA_DIRECTORY    DataDir2    <comment="IMAGE_DIRECTORY_ENTRY_RESOURCE">;
    IMAGE_DATA_DIRECTORY    DataDir3    <comment="IMAGE_DIRECTORY_ENTRY_EXCEPTION">;
    IMAGE_DATA_DIRECTORY    DataDir4    <comment="IMAGE_DIRECTORY_ENTRY_SECURITY">;
    IMAGE_DATA_DIRECTORY    DataDir5    <fgcolor=cPurple,comment="IMAGE_DIRECTORY_ENTRY_BASERELOC">;
    IMAGE_DATA_DIRECTORY    DataDir6    <comment="IMAGE_DIRECTORY_ENTRY_DEBUG">;
    IMAGE_DATA_DIRECTORY    DataDir7    <comment="IMAGE_DIRECTORY_ENTRY_ARCHITECTURE">;
    IMAGE_DATA_DIRECTORY    DataDir8   <comment="IMAGE_DIRECTORY_ENTRY_GLOBALPTR">;
    IMAGE_DATA_DIRECTORY    DataDir9   <comment="IMAGE_DIRECTORY_ENTRY_TLS">;
    IMAGE_DATA_DIRECTORY    DataDir10   <comment="IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG">;
    IMAGE_DATA_DIRECTORY    DataDir11   <comment="IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT">;
    IMAGE_DATA_DIRECTORY    DataDir12   <fgcolor=cPurple,comment="IMAGE_DIRECTORY_ENTRY_IAT">;
    IMAGE_DATA_DIRECTORY    DataDir13   <comment="IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT">;
    IMAGE_DATA_DIRECTORY    DataDir14   <comment="IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR">;
    IMAGE_DATA_DIRECTORY    DataDir15   <comment="System Reserved">;
}IMAGE_DATA_DIRECTORY_ARRAY;

typedef enum<WORD> _IMAGE_SUBSYSTEM
{
    IMAGE_SUBSYSTEM_UNKNOWN =0,   // Unknown subsystem.
    NATIVE                  =1,  // Image doesn't require a subsystem.
    WINDOWS_GUI             =2,   // Image runs in the Windows GUI subsystem.
    WINDOWS_CUI             =3,   // Image runs in the Windows character subsystem.
    OS2_CUI                 =5,   // image runs in the OS/2 character subsystem.
    POSIX_CUI               =7,   // image runs in the Posix character subsystem.
    NATIVE_WINDOWS          =8,   // image is a native Win9x driver.
    WINDOWS_CE_GUI          =9,   // Image runs in the Windows CE subsystem.
    EFI_APPLICATION         =10,  
    EFI_BOOT_SERVICE_DRIVER =11,   
    EFI_RUNTIME_DRIVER      =12,  
    EFI_ROM                 =13,
    XBOX                    =14,
    WINDOWS_BOOT_APPLICATION=16
}IMAGE_SUBSYSTEM<comment="WORD">;

typedef struct _DLL_CHARACTERISTICS
{
    WORD IMAGE_LIBRARY_PROCESS_INIT:1   <comment="0x0001 Reserved",hidden=true>;
    WORD IMAGE_LIBRARY_PROCESS_TERM:1   <comment="0x0002 Reserved",hidden=true>; 
    WORD IMAGE_LIBRARY_THREAD_INIT:1    <comment="0x0004 Reserved",hidden=true>;
    WORD IMAGE_LIBRARY_THREAD_TERM:1    <comment="0x0008 Reserved",hidden=true>;
    WORD                           :2   <comment="0x0010,0x0020",hidden=true>;
    WORD IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE:1            <comment="0x0040">;
    WORD IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY:1         <comment="0x0080">;
    WORD IMAGE_DLLCHARACTERISTICS_NX_COMPAT:1               <comment="0x0100">;
    WORD IMAGE_DLLCHARACTERISTICS_NO_ISOLATION:1            <comment="0x0200">;
    WORD IMAGE_DLLCHARACTERISTICS_NO_SEH:1                  <comment="0x0400">;
    WORD IMAGE_DLLCHARACTERISTICS_NO_BIND:1                 <comment="0x0800">;
    WORD                                  :1                <comment="0x1000",hidden=true>;
    WORD IMAGE_DLLCHARACTERISTICS_WDM_DRIVER:1              <comment="0x2000">;
    WORD                                     :1             <comment="0x4000",hidden=true>;
    WORD IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE:1   <comment="0x8000">;
}DLL_CHARACTERISTICS <comment="WORD">;

typedef enum<WORD> _OPTIONAL_MAGIC
{
    PE32=0x10b,
    PE64=0x20b,
    ROM=0x107
}OPTIONAL_MAGIC <comment="WORD">;

typedef struct _IMAGE_OPTIONAL_HEADER32
{
    OPTIONAL_MAGIC    Magic     <format=hex>;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode          <format=hex>;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint <fgcolor=cPurple,format=hex,comment=CommentRVA2FOA>;
    DWORD   BaseOfCode          <format=hex,comment=CommentRVA2FOA>;
    DWORD   BaseOfData          <format=hex,comment=CommentRVA2FOA>;
    DWORD   ImageBase           <format=hex>;
    DWORD   SectionAlignment    <format=hex>;
    DWORD   FileAlignment       <format=hex>;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage         <format=hex>;
    DWORD   SizeOfHeaders       <format=hex>;
    DWORD   CheckSum            <format=hex>;
    IMAGE_SUBSYSTEM    Subsystem;
    DLL_CHARACTERISTICS    DllCharacteristics;
    DWORD   SizeOfStackReserve  <format=hex>;
    DWORD   SizeOfStackCommit   <format=hex>;
    DWORD   SizeOfHeapReserve   <format=hex>;
    DWORD   SizeOfHeapCommit    <format=hex>;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY_ARRAY  DataDirArray;
}IMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_OPTIONAL_HEADER64
{
    OPTIONAL_MAGIC        Magic   <format=hex>;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint <format=hex,comment=CommentRVA2FOA>;
    DWORD       BaseOfCode  <format=hex>;
    ULONGLONG   ImageBase   <format=hex>;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage <format=hex>;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    IMAGE_SUBSYSTEM    Subsystem;
    DLL_CHARACTERISTICS        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve <format=hex>;
    ULONGLONG   SizeOfStackCommit <format=hex>;
    ULONGLONG   SizeOfHeapReserve <format=hex>;
    ULONGLONG   SizeOfHeapCommit <format=hex>;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY_ARRAY  DataDirArray;
}IMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS 
{
    DWORD Signature <format=hex,comment="IMAGE_NT_SIGNATURE = 0x00004550">;
    IMAGE_FILE_HEADER FileHeader;
    
    local WORD OptionalHeaderMagic = ReadShort(FTell());

    if (0x10b == OptionalHeaderMagic)
    {
        IMAGE_OPTIONAL_HEADER32 OptionalHeader;
    }
    else if (0x20b == OptionalHeaderMagic)
    {
        IMAGE_OPTIONAL_HEADER64 OptionalHeader;
    }
    else
    {
        Printf("not valid Optional header magic %x.\n",OptionalHeaderMagic);
       return 1;
    }
}IMAGE_NT_HEADERS <size=CalcImageNtHeadersSize>;

int CalcImageNtHeadersSize(IMAGE_NT_HEADERS& stNtHeader)
{
    local WORD OptionalHeaderMagic = ReadShort(startof(stNtHeader) + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) );    

    if(0x10B ==  OptionalHeaderMagic)
    {
        Printf("PE32\n");
        return 0xF8;    //sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + sizeof(IMAGE_OPTIONAL_HEADER32);
    }
    else if (0x20B == OptionalHeaderMagic)
    {
        Printf("PE64\n");
        return 0x108;   //sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + sizeof(IMAGE_OPTIONAL_HEADER64);
    }
    else
    {
        return sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + 0; //
    }
    return 0;
}

typedef struct _SECTION_CHARACTERISTICS
{
    ULONG IMAGE_SCN_TYPE_DSECT:1                 <hidden=true,comment="0x00000001 Reserved">;
    ULONG IMAGE_SCN_TYPE_NOLOAD:1                <hidden=true,comment="0x00000002 Reserved">;
    ULONG IMAGE_SCN_TYPE_GROUP:1                 <hidden=true,comment="0x00000004 Reserved">;
    ULONG IMAGE_SCN_TYPE_NO_PAD:1                <comment="0x00000008 Reserved">;
    ULONG IMAGE_SCN_TYPE_COPY:1                  <hidden=true,comment="0x00000010 Reserved">;

    ULONG IMAGE_SCN_CNT_CODE:1                   <comment="0x00000020 Section contains code">;
    ULONG IMAGE_SCN_CNT_INITIALIZED_DATA:1       <comment="0x00000040 Section contains initialized data">;
    ULONG IMAGE_SCN_CNT_UNINITIALIZED_DATA:1     <comment="0x00000080 Section contains uninitialized data">;
    
    ULONG IMAGE_SCN_LNK_OTHER:1                  <comment="0x00000100 Reserved">;
    ULONG IMAGE_SCN_LNK_INFO:1                   <comment="0x00000200 Section contains comments or some other type of information">;
    ULONG IMAGE_SCN_TYPE_OVER:1                  <hidden=true,comment="0x00000400 Reserved">;
    ULONG IMAGE_SCN_LNK_REMOVE:1                 <comment="0x00000800 Section contents will not become part of image">;
    ULONG IMAGE_SCN_LNK_COMDAT:1                 <comment="0x00001000 Section contents comdat">;
    ULONG                      :1                <comment="0x00002000 Reserved">;
    ULONG IMAGE_SCN_NO_DEFER_SPEC_EXC:1          <hidden=true,comment="0x00004000 Reset speculative exceptions handling bits in the TLB entries for this section.">;
    ULONG IMAGE_SCN_GPREL:1                      <comment="0x00008000 Section content can be accessed relative to GP">;
    ULONG IMAGE_SCN_MEM_SYSHEAP:1                <hidden=true,comment="0x00010000 Obsolete">;
    ULONG IMAGE_SCN_MEM_16BIT:1                  <comment="0x00020000">;
    ULONG IMAGE_SCN_MEM_LOCKED:1                 <comment="0x00040000 ">;
    ULONG IMAGE_SCN_MEM_PRELOAD:1                <comment="0x00080000">;
    
    ULONG IMAGE_SCN_ALIGN_1BYTES:1               <comment="0x00100000">;  
    ULONG IMAGE_SCN_ALIGN_2BYTES:1               <comment="0x00200000">; 
    ULONG IMAGE_SCN_ALIGN_8BYTES:1               <comment="0x00400000">;
    ULONG IMAGE_SCN_ALIGN_128BYTES:1             <comment="0x00800000">; 

    ULONG IMAGE_SCN_LNK_NRELOC_OVFL:1            <comment="0x01000000 Section contains extended relocations">; 
    ULONG IMAGE_SCN_MEM_DISCARDABLE:1            <comment="0x02000000 Section can be discarded.">;
    ULONG IMAGE_SCN_MEM_NOT_CACHED:1             <comment="0x04000000 Section is not cachable">;  
    ULONG IMAGE_SCN_MEM_NOT_PAGED:1              <comment="0x08000000 Section is not pageable.">; 
    ULONG IMAGE_SCN_MEM_SHARED:1                 <comment="0x10000000 Section is shareable">;  
    ULONG IMAGE_SCN_MEM_EXECUTE:1                <comment="0x20000000 Section is executable">; 
    ULONG IMAGE_SCN_MEM_READ:1                   <comment="0x40000000 Section is readable">;  
    ULONG IMAGE_SCN_MEM_WRITE:1                  <comment="0x80000000 Section is writeable">;  
}SECTION_CHARACTERISTICS;

typedef struct _IMAGE_SECTION_HEADER 
{
    BYTE    Name[8] <comment="can end without zero">;
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress      <format=hex>;
    DWORD   SizeOfRawData       <format=hex>;
    DWORD   PointerToRawData    <format=hex>;
    DWORD   PointerToRelocations<format=hex>;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    SECTION_CHARACTERISTICS   Characteristics     <format=hex>;
}IMAGE_SECTION_HEADER;

typedef struct _IMAGE_SECTION_DATA(IMAGE_SECTION_HEADER& SecHeader)
{
    local string sSecName=SecHeader.Name;

    UCHAR Data[SecHeader.SizeOfRawData];
}IMAGE_SECTION_DATA <comment=commentSectionData>;

string commentSectionData(IMAGE_SECTION_DATA& SecData)
{
    return SecData.sSecName;
}

typedef struct _IMAGE_IMPORT_BY_NAME(int nNameLen)
{
    WORD    Hint;
    BYTE    Name[nNameLen];
} IMAGE_IMPORT_BY_NAME <comment=commentImageImportByName>;

string commentImageImportByName(IMAGE_IMPORT_BY_NAME& ImportByName)
{
    return ImportByName.Name;
}

typedef struct _IMAGE_IMPORT_DESCRIPTOR 
{
    local int   nNameIndex=0;
    local ULONG ulThrunk=0;
    local int   nNameLen=0;
    local string sDllName="";
    local ULONG ulOriginalFirstThunkFOA=0;

    union 
    {
        ULONG   Characteristics;  
        ULONG   OriginalFirstThunk <format=hex,comment=CommentRVA2FOA>;
    }DUMMYUNIONNAME;

    ULONG   TimeDateStamp   <comment="0 if not bound">; 
    ULONG   ForwarderChain  <comment="-1 if no forwarders">;
    ULONG   Name        <format=hex,comment=CommentRVAString>;
    ULONG   FirstThunk  <format=hex,comment=CommentRVA2FOA>;


    ulOriginalFirstThunkFOA = RVA2FOA(DUMMYUNIONNAME.OriginalFirstThunk);
    if ((0x20b == NtHeader.OptionalHeader.Magic))
    {
                   
    }
    else
    {
        nNameIndex =0;
        while(1)
        {
            ulThrunk = ReadUInt(ulOriginalFirstThunkFOA + 4 * nNameIndex);           
            if (0 == ulThrunk)
            {
                break;
            }     
	              
            if (ulThrunk & 0x80000000)
            {
		        Printf("mport by order \n");
            }
            else
            {
                nNameLen = Strlen(ReadString(RVA2FOA(ulThrunk) + sizeof(WORD)));
                if(0 != nNameLen)
                {
                    FSeek(RVA2FOA(ulThrunk));
                    IMAGE_IMPORT_BY_NAME ImportByName(nNameLen +1)<open=false>;
                }
	       }
        nNameIndex++;
     }
  }
}IMAGE_IMPORT_DESCRIPTOR <comment=commentImageImportDescriptor>;

string commentImageImportDescriptor(IMAGE_IMPORT_DESCRIPTOR& ImportDescriptor)
{
    return ReadString( RVA2FOA(ImportDescriptor.Name));
}

typedef struct _IMAGE_EXPORT_BY_NAME(string& sExportFuncName,ULONG ulDestRVA,string& sJmpName)
{
   local ULONG ulLocalDestRVA=ulDestRVA;
   local string sLocalJmpName=sJmpName;

   char Function[Strlen(sExportFuncName)];
}IMAGE_EXPORT_BY_NAME <read=ReadExportByName,comment=commentExportByName>;

string ReadExportByName(IMAGE_EXPORT_BY_NAME& ExportByName)
{
    return ExportByName.Function;
}

string commentExportByName(IMAGE_EXPORT_BY_NAME& ExportByName)
{
    local string sComment="";

    if (0 == Strlen(ExportByName.sLocalJmpName) )
    {
        SPrintf(sComment,"0x%X",ExportByName.ulLocalDestRVA);
    }
    else
    {
        SPrintf(sComment,"%s",ExportByName.sLocalJmpName);
    }
    
    return sComment;
}

typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    time_t   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name <format=hex,comment=CommentRVAString>;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions      <format=hex,comment=CommentRVA2FOA>;     // RVA from base of image
    DWORD   AddressOfNames          <format=hex,comment=CommentRVA2FOA>;         // RVA from base of image
    DWORD   AddressOfNameOrdinals   <format=hex,comment=CommentRVA2FOA>;  // RVA from base of image

    local int   nIndex=0;
    local ULONG NameArrayFOA=0;
    local ULONG OrdinalArrayFOA=0;
    local ULONG FuncArrayFOA=0;
    local ULONG ulNameRVA=0;  
    local ULONG ulNameFOA=0;
    local ULONG ulFuncRVA=0;
    local WORD  wOrdinal=0;
    
    local string sExportName="";
    local string sJmpName="";
   
    //List Export names.
    NameArrayFOA = RVA2FOA(ExportDir.AddressOfNames);
    OrdinalArrayFOA = RVA2FOA(ExportDir.AddressOfNameOrdinals);
    FuncArrayFOA    = RVA2FOA(ExportDir.AddressOfFunctions);
    
    for(nIndex=0; nIndex < ExportDir.NumberOfNames; nIndex++)
    {
        ulNameRVA = ReadUInt(NameArrayFOA + nIndex*sizeof(ULONG) );        
        ulNameFOA = RVA2FOA(ulNameRVA);
        sExportName = ReadString(ulNameFOA);
            
        if (0 != Strlen(sExportName))
        {
            wOrdinal = ReadUShort(OrdinalArrayFOA + nIndex*sizeof(USHORT));
            ulFuncRVA = ReadUInt(FuncArrayFOA + wOrdinal* sizeof(ULONG) ); //GetRVA
                
            if ( (ulFuncRVA >NtHeader.OptionalHeader.DataDirArray.DataDir0.VirtualAddress ) && \
                (ulFuncRVA < NtHeader.OptionalHeader.DataDirArray.DataDir0.VirtualAddress + NtHeader.OptionalHeader.DataDirArray.DataDir0.Size ) )
            {
                //is a jmp
    
              sJmpName = ReadString( RVA2FOA(ulFuncRVA) );
              FSeek(ulNameFOA);
              IMAGE_EXPORT_BY_NAME ExportByName(sExportName,ulFuncRVA,sJmpName);
            }       
            else
            {
              //normal
              sJmpName ="";
              FSeek(ulNameFOA);
              IMAGE_EXPORT_BY_NAME ExportByName(sExportName,ulFuncRVA,sJmpName);
            }
        }
    }
}IMAGE_EXPORT_DIRECTORY <comment=commentExportDirectory>;

string commentExportDirectory(IMAGE_EXPORT_DIRECTORY& ExportDir)
{
    return ReadString(RVA2FOA(ExportDir.Name));
}

ULONG RVA2FOA(ULONG ulRVA)
{
    local int i=0;  
    
    for(i=0; i < NtHeader.FileHeader.NumberOfSections; i++)
    {
        if ( (ulRVA >= SectionHeaders[i].VirtualAddress) && (ulRVA <= SectionHeaders[i].VirtualAddress + SectionHeaders[i].SizeOfRawData) )
        {
          return SectionHeaders[i].PointerToRawData + (ulRVA - SectionHeaders[i].VirtualAddress);
        } 
    }
    return 0;
}

string LocationRVA(ULONG ulRVA)
{
    local int i=0;  
    
    for(i=0; i < NtHeader.FileHeader.NumberOfSections; i++)
    {
        if ( (ulRVA >= SectionHeaders[i].VirtualAddress) && (ulRVA <= SectionHeaders[i].VirtualAddress + SectionHeaders[i].SizeOfRawData) )
        {
          return SectionHeaders[i].Name;
        } 
    }
    return "";
}

string CommentRVA2FOA(DWORD dwRVA)
{
   local string sComment="";
   if (0 != dwRVA)
   {
     SPrintf(sComment,"%s FOA = 0x%X \n",LocationRVA(dwRVA),RVA2FOA(dwRVA));   
   }
   return sComment;
}

string CommentRVAString(DWORD dwRVA)
{
    local string sComment="";

    if (0 != dwRVA)
    {
        SPrintf(sComment,"%s FOA = 0x%X -> %s",LocationRVA(dwRVA),RVA2FOA(dwRVA),ReadString(RVA2FOA(dwRVA)) );
    }
    return sComment; 
}

typedef struct _IMAGE_BASE_RELOCATION
{
    DWORD   VirtualAddress <format=hex,comment=CommentRVA2FOA>;
    DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];

    local ULONG ulBlockNum=0;
    local ULONG ulIndex=0;
    
    ulBlockNum = (SizeOfBlock - 8)/2;
    for(ulIndex=0; ulIndex< ulBlockNum ;ulIndex++)
    {
        WORD Block<format=hex,comment=CommentBaseRelocBlock>;
    }
    
} IMAGE_BASE_RELOCATION <comment=commentImageBaseRelocation>;



string CommentBaseRelocBlock(WORD Block)
{
    if(0x3000 == (Block & 0xF000) )
    {
        return "HIGHLOW";
    }
    else
    {
        return "ABSULUTE";
    }

    return "";
}


string commentImageBaseRelocation(IMAGE_BASE_RELOCATION& BaseReloc)
{
    local string sComment="";
    SPrintf(sComment,"%d",BaseReloc.ulBlockNum);
    return sComment;
}

typedef struct _BASE_RELOCATION_TABLE
{   
    local ULONG ulRelocNum=0;

    while(1)
    {
        if(0 == ReadUInt(FTell()) )
        {
            break;
        }
        IMAGE_BASE_RELOCATION BaseReloc;
        ulRelocNum++;
    }
}BASE_RELOCATION_TABLE <comment=commentBaseRelocationTable>;

string commentBaseRelocationTable(BASE_RELOCATION_TABLE& RelocTable)
{
    local string sComment="";
    SPrintf(sComment,"%d",RelocTable.ulRelocNum);
    return sComment;
}



//Parse Export Directory
void ParseEAT(void)
{ 
    if( (NtHeader.OptionalHeader.DataDirArray.DataDir0.VirtualAddress != 0) && (NtHeader.OptionalHeader.DataDirArray.DataDir0.Size != 0) )
    {
        local ULONG ulExportFOA= RVA2FOA(NtHeader.OptionalHeader.DataDirArray.DataDir0.VirtualAddress);
        FSeek(ulExportFOA);
        IMAGE_EXPORT_DIRECTORY ExportDir;
    }
}

//Import Directory
void ParseIAT()
{
    if( (NtHeader.OptionalHeader.DataDirArray.DataDir1.VirtualAddress != 0) && (NtHeader.OptionalHeader.DataDirArray.DataDir1.Size != 0) )
    {
        local ULONG ulImportFOA = RVA2FOA(NtHeader.OptionalHeader.DataDirArray.DataDir1.VirtualAddress);    //Import 
        local ULONG ulOriginalFirstThunk=0;
        local ULONG ulOriginalFirstThunkFOA=0;
        local int   nImportIndex=0;

        FSeek(ulImportFOA);
        while(1)
        {
            ulOriginalFirstThunk = ReadUInt(ulImportFOA + 0x14*nImportIndex );
            if (0 == ulOriginalFirstThunk)
            {
                break;
            }
            FSeek(ulImportFOA + 0x14*nImportIndex);
            IMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
            nImportIndex++;
        }
    }
}

//Resource Directory 2
void ParseResource()
{
    if( (NtHeader.OptionalHeader.DataDirArray.DataDir2.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.DataDir2.Size == 0) )
    {
       return;
    }
    //FixMe
}

//Exception Directory 3
void ParseException()
{
    if( (NtHeader.OptionalHeader.DataDirArray.DataDir3.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.DataDir3.Size == 0) )
    {
       return;
    }
    //FixMe
}

//Security Directory 4
void ParseSecurity()
{
    if( (NtHeader.OptionalHeader.DataDirArray.DataDir4.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.DataDir4.Size == 0) )
    {
       return;
    }
    //FixMe
}

//Relocation Directory 5
void ParseBaseReloc()
{
    if( (NtHeader.OptionalHeader.DataDirArray.DataDir5.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.DataDir5.Size == 0) )
    {
       return;
    }
    FSeek( RVA2FOA(NtHeader.OptionalHeader.DataDirArray.DataDir5.VirtualAddress) );
    BASE_RELOCATION_TABLE RelocTable;
}

//Debug Directory 6
void ParseDebug()
{
    if( (NtHeader.OptionalHeader.DataDirArray.DataDir6.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.DataDir6.Size == 0) )
    {
       return;
    }
    //FixMe
}

//TLS 9
void ParseTLS()
{
    if( (NtHeader.OptionalHeader.DataDirArray.DataDir9.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.DataDir9.Size == 0) )
    {
       return;
    }

    //FixMe
}

//Bound Import 11
void ParseBoundImport()
{
    if( (NtHeader.OptionalHeader.DataDirArray.DataDir11.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.DataDir11.Size == 0) )
    {
       return;
    }
    //FixMe
}

//Delay Import 13
void ParseDelayImport()
{
    if( (NtHeader.OptionalHeader.DataDirArray.DataDir13.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.DataDir13.Size == 0) )
    {
       return;
    }
    //FixMe
}

//CLI Header Directory 14

///
/// Get the required padding
///
int calculatePadding(int length)
{
    if(length < 4)
    {
        return 4 - length;
    }
    else
    {
        return 4 - length % 4;
    }
}

///
/// Need to make this more advanced for null terminator problems.
///
int readAheadToGetStringLength(int currentPos)
{
    return ReadStringLength(currentPos,-1);
}

///
/// Compute number of Valid tables
///
int ComputeValidTableNumber()
{
    local short i;
    local DWORD mask = 0x00000001;
    local DWORD currentmask;
    currentmask = mask;
    local int count = 0;

    Printf("List of valid table : ");

    for (i=0; i < 32; i++)
    {
      if ((sharpStream.validLower & currentmask)!=0) {
          Printf("%d, ",i);
          count++;
      }
      currentmask =  mask << (i+1);
    }
 
    mask = 0x00000001;
    currentmask = mask;

    for (i=0; i < 32; i++)
    {
      if ((sharpStream.validHigher & currentmask)!=0) {
          Printf("%d, ",i+32);
          count++;
      }
      currentmask =  mask << (i+1);
      //Printf("%d mask=%lx\n",i, currentmask);
  
    }

    Printf("\n");
    return count;
}

///
/// Check if table is valid
///
int isValidTable(QWORD tableflag)
{

  if(tableflag < 0x100000000)  
  {
    if((sharpStream.validLower & tableflag) != 0)
    {
       return true;
    } 
  }
  else
  {
    if((sharpStream.validHigher & (tableflag >> 32)  ) != 0)
    {
       return true;
    } 
  }

   return false;
}

///
/// Display GUID format
///
void ReadGUID123(int64 iPosition, int32 &iData1, int16 &iData2, int16 &iData3)
{
    iData1 = ReadUInt(iPosition);
    iPosition += 4;
    iData2 = ReadUShort(iPosition);
    iPosition += 2;
    iData3 = ReadUShort(iPosition);
    iPosition += 2;
}

void ReadGUID4(int64 iPosition, int16 &iData4a, int16 &iData4b, int32 &iData4c)
{
    iData4a = ReadUShort(iPosition);
    iPosition += 2;
    iData4b = ReadUShort(iPosition);
    iPosition += 2;
    iData4c = ReadUInt(iPosition);
    iPosition += 4;
}

string FormatGUID(int64 empty)
{
    local string sGUID;
    local int32 iData1;
    local int16 iData2;
    local int16 iData3;
    local int16 iData4a;
    local int16 iData4b;
    local int32 iData4c;
    local int iStartedAsBigEndian;
    local int64 iPosition = GetCursorPos();

    iStartedAsBigEndian = IsBigEndian();
    LittleEndian();
    ReadGUID123(iPosition, iData1, iData2, iData3);
    BigEndian();
    ReadGUID4(iPosition + 8, iData4a, iData4b, iData4c);
    if (!iStartedAsBigEndian)
        LittleEndian();
    SPrintf(sGUID, "{%08X-%04X-%04X-%04X-%04X%08X}", iData1, iData2 & 0x0000FFFF, iData3 & 0x0000FFFF, iData4a & 0x0000FFFF, iData4b & 0x0000FFFF, iData4c);

    return sGUID;
}

///////////////////////////////////////////////////////////////////////////
// II.25.3.3
// CLI Header
///////////////////////////////////////////////////////////////////////////
// II.25.3.3.1 
typedef struct _Runtimeflags
{
    DWORD COMIMAGE_FLAGS_ILONLY:1		<comment="0x00000001">; 
    DWORD COMIMAGE_FLAGS_32BITREQUIRED:1	<comment="Image can only be loaded into a 32-bit process, for instance if there are 32-bit vtablefixups, or casts from native integers to int32. CLI implementations that have 64-bit native integers shall refuse loading binaries with this flag set.">;
    DWORD COMIMAGE_FLAGS_STRONGNAMESIGNED:1	<comment="Image has a strong name signature.">;
    DWORD COMIMAGE_FLAGS_NATIVE_ENTRYPOINT:1	<comment="0x00000010">;
    DWORD COMIMAGE_FLAGS_TRACKDEBUGDATA:1	<comment="0x00010000">; 
}Runtimeflags <comment="DWORD">;

typedef struct _CLI_HEADER 
{
    DWORD   Cb <comment="Size of the header in bytes">;
    WORD    MajorRuntimeVersion <comment="The minimum version of the runtime required to run this program, currently 2">;
    WORD    MinorRuntimeVersion <comment="The minor portion of the version, currently 0.">;
    DWORD   MetaDataRVA <format=hex,comment="RVA of the physical metadata">;
    DWORD   MetaDataSiZE <format=hex,comment="Size of the physical metadata">;
 
    Runtimeflags   Flags <fgcolor=cPurple,format=hex,comment="Flags describing this runtime image">;
    DWORD   EntryPointToken <format=hex,comment="Token for the MethodDef or File of the entry point for the image">;
    QWORD   Resources <format=hex,comment="RVA and size of implementation-specific resources.">;
    QWORD   StrongNameSignature <format=hex,comment="RVA of the hash data for this PE file used by the CLI loader for binding and versioning">;
    QWORD   CodeManagerTable  <comment="Always 0">;
    QWORD   VTableFixups <format=hex,comment="RVA of an array of locations in the file that contain an array of function pointers (e.g., vtable slots), see below.">;
    QWORD   ExportAddressTableJumps <comment="Always 0">;
    QWORD   ManagedNativeHeader <comment="Always 0">;

}SECTION_CLI_HEADER;

///////////////////////////////////////////////////////////////////////////
// II.24.2.1
// Metadata root
///////////////////////////////////////////////////////////////////////////
typedef struct _PHYSICAL_METADATA_HEADER 
{
    DWORD Signature <format=hex,comment="Magic signature for physical metadata : 0x424A5342.">;
    WORD  MajorVersion;
    WORD  MinorVersion;
    DWORD Reserved;
    DWORD Length <format=hex,comment="Number of bytes allocated to hold version string (including null terminator)">;
    BYTE  Version[Length]; 
    if(Length % 4 != 0)
    {
        BYTE padding[calculatePadding(Length)];
    }
    WORD  Flags <comment="Reserved, always 0">;
    WORD  Streams <comment="Number of streams">;

}PHYSICAL_METADATA_HEADER;

///////////////////////////////////////////////////////////////////////////
// II.24.2.2
// Stream header
///////////////////////////////////////////////////////////////////////////
local int stringLength;

struct STREAM_HEADER 
{
    DWORD Offset <format=hex,comment="Memory offset to start of this stream from start of the metadata root">;
    DWORD Size <format=hex,comment="Size of this stream in bytes, shall be a multiple of 4.">;

    stringLength = readAheadToGetStringLength(FTell());

    char  Name[stringLength]; 
    if(stringLength % 4 != 0)
    {
        BYTE padding[calculatePadding(stringLength)];
    }
};

////////////////////////////////////
// II.24.2.6  #~ Stream
////////////////////////////////////
typedef struct _INDEX_SIZE
{
    BYTE StringsIndexSize:1        <comment="If bit is not set, all indices into this stream require four bytes">;
    BYTE GUIDIndexSize:1           <comment="If bit is not set, all indices into this stream require four bytes">;
    BYTE BlobIndexSize:1           <comment="If bit is not set, all indices into this stream require four bytes">;
}INDEX_SIZE <comment="BYTE">;;

typedef struct _SHARP_STREAM 
{
    DWORD Reserved <comment="Reserved, always 0">;
    BYTE  MajorVersion <comment="Major version of table schemata; shall be 2">;
    BYTE  MinorVersion <comment="Minor version of table schemata; shall be 0">;
    BYTE  HeapSizes <format=hex,comment="Bit vector for heap sizes (0 for two-byte index)">;
    BYTE  Reserved <comment="Reserved, always 1">;
    DWORD validLower <format=binary,comment="Bit vector of present tables, let n be the number of bits that are 1">;
    DWORD validHigher <format=binary,comment="Bit vector of present tables, let n be the number of bits that are 1">;
    // BUG in 010 editor
    //QWORD Valid <format=binary,comment="Bit vector of present tables, let n be the number of bits that are 1">;
    QWORD Sorted <format=binary,comment="Bit vector of sorted tables.">;

}SHARP_STREAM;

typedef struct _FAT_FORMAT
{
    WORD Flags_Size <format=hex,comment="Flags (CorILMethod_FatFormat shall be set in bits 0:1 / Size of this header expressed as the count of 4-byte integers occupied (currently 3)">;
    WORD  MaxStack <comment="Maximum number of items on the operand stack">;
    DWORD CodeSize <format=hex,comment="Size in bytes of the actual method body">;
    DWORD LocalVarSigTok <format=hex,comment="Meta Data token for a signature describing the layout of the local variables for the method. 0 means there are no local variables present">;
    WORD MethodDataSection <format=hex>;
}FAT_FORMAT;

enum <QWORD> TABLE_TYPE
{
    enumModule = 1,				// table 0
    enumTypeRef = 2,				// table 1
    enumTypeDef = 4,				// table 2
    Reserved1 = 8,				// table 3
    enumField = 16,				// table 4
    Reserved2 = 32,				// table 5
    enumMethod = 64,				// table 6
    Reserved3 = 128,				// table 7
    enumParam = 256,				// table 8
    enumInterfaceImpl = 512,			// table 9
    enumMemberRef = 1024,			// table 10
    enumConstant = 2048,			// table 11
    enumCustomAttribute = 4096,			// table 12
    enumFieldMarshal = 8192,			// table 13
    enumDeclSecurity = 16384,			// table 14
    enumClassLayout = 32768,			// table 15
    enumFieldLayout = 65536,			// table 16				
    enumStandAloneSig = 131072,			// table 17
    enumEventMap = 262144,			// table 18
    Reserved4 = 524288,				// table 19
    enumEvent = 1048576,			// table 20
    enumPropertyMap = 2097152,			// table 21
    Reserved5 = 4194304,			// table 22
    enumProperty = 8388608,			// table 23
    enumMethodSemantics = 16777216,		// table 24
    enumMethodImpl = 33554432,			// table 25
    enumModuleRef = 67108864,			// table 26
    enumTypeSpec = 134217728,			// table 27
    enumImplMap = 268435456,			// table 28
    enumFieldRVA = 536870912,			// table 29
    Reserved6 = 1073741824,			// table 30
    Reserved7 = 2147483648,			// table 31
    enumAssembly = 4294967296,			// table 32
    enumAssemblyProcessor = 8589934592,		// table 33
    enumAssemblyOS = 17179869184,		// table 34
    enumAssemblyRef = 34359738368,		// table 35
    enumAssemblyRefProcessor = 68719476736,	// table 36
    enumAssemblyRefOS = 137438953472,		// table 37
    enumFile = 274877906944,			// table 38
    enumExportedType = 549755813888,		// table 39
    enumManifestResource = 1099511627776,	// table 40
    enumNestedClass = 2199023255552,		// table 41
    enumGenericParam = 4398046511104,		// table 42
    enumMethodSpec = 8796093022208,		// table 43
    enumGenericParamConstraint = 17592186044416 // table 44   00 00 10 00   00 00 00 00
};

///////////////////////////////////////////////////////////////////////////
// II.22.30
// Module : 0x00
///////////////////////////////////////////////////////////////////////////
typedef struct _MODULE_TABLE_ROW
{
   WORD Generation <format=hex,comment="a 2-byte value, reserved, shall be zero">;
   
   //if((BYTE)sharpStream.HeapSizes & (BYTE)StringsIndexSize) 
   if((sharpStream.HeapSizes & 0x01)==1)  // StringsIndexSize
 	   DWORD Name <format=hex,comment="an index into the String heap">;
   else
           WORD Name <format=hex,comment="an index into the String heap">;

   if((sharpStream.HeapSizes & 0x02)==1) { // GUIDIndexSize
    	   DWORD Mvid <format=hex,comment="an index into the Guid heap; simply a Guid used to distinguish between two versions of the same module">;
           DWORD EncId <format=hex,comment="an index into the Guid heap; reserved, shall be zero">;
           DWORD EncBaseId <format=hex,comment="an index into the Guid heap; reserved, shall be zero">;
   }
   else
   {
           WORD Mvid <format=hex,comment="an index into the Guid heap; simply a Guid used to distinguish between two versions of the same module">;
           WORD EncId <format=hex,comment="an index into the Guid heap; reserved, shall be zero">;
           WORD EncBaseId <format=hex,comment="an index into the Guid heap; reserved, shall be zero">;
   }
}MODULE_TABLE_ROW;

///////////////////////////////////////////////////////////////////////////
// II.22.38
// TypeRef : 0x01
///////////////////////////////////////////////////////////////////////////
typedef struct _TYPEREF_TABLE_ROW
{
   WORD ResolutionScope <format=hex,comment="index into Module, ModuleRef, AssemblyRef or TypeRef tables, or null; more precisely, a ResolutionScope coded index">;
   if((sharpStream.HeapSizes & 0x01)==1)  // StringsIndexSize
   {
      DWORD TypeName <format=hex,comment="index into String heap">;
      DWORD TypeNamespace <format=hex,comment="index into String heap">;
   }
   else
   {
      WORD TypeName <format=hex,comment="index into String heap">;
      WORD TypeNamespace <format=hex,comment="index into String heap">;
   }
}TYPEREF_TABLE_ROW;

///////////////////////////////////////////////////////////////////////////
// II.22.37
// TypeDef : 0x02
///////////////////////////////////////////////////////////////////////////
typedef enum <DWORD> CorTypeAttr
{
    // Use this mask to retrieve the type visibility information.
    tdVisibilityMask        =   0x00000007,
    tdNotPublic             =   0x00000000,     // Class is not public scope.
    tdPublic                =   0x00000001,     // Class is public scope.
    tdNestedPublic          =   0x00000002,     // Class is nested with public visibility.
    tdNestedPrivate         =   0x00000003,     // Class is nested with private visibility.
    tdNestedFamily          =   0x00000004,     // Class is nested with family visibility.
    tdNestedAssembly        =   0x00000005,     // Class is nested with assembly visibility.
    tdNestedFamANDAssem     =   0x00000006,     // Class is nested with family and assembly visibility.
    tdNestedFamORAssem      =   0x00000007,     // Class is nested with family or assembly visibility.

    // Use this mask to retrieve class layout information
    tdLayoutMask            =   0x00000018,
    tdAutoLayout            =   0x00000000,     // Class fields are auto-laid out
    tdSequentialLayout      =   0x00000008,     // Class fields are laid out sequentially
    tdExplicitLayout        =   0x00000010,     // Layout is supplied explicitly
    // end layout mask

    // Use this mask to retrieve class semantics information.
    tdClassSemanticsMask    =   0x00000060,
    tdClass                 =   0x00000000,     // Type is a class.
    tdInterface             =   0x00000020,     // Type is an interface.
    // end semantics mask

    // Special semantics in addition to class semantics.
    tdAbstract              =   0x00000080,     // Class is abstract
    tdSealed                =   0x00000100,     // Class is concrete and may not be extended
    tdSpecialName           =   0x00000400,     // Class name is special. Name describes how.

    // Implementation attributes.
    tdImport                =   0x00001000,     // Class / interface is imported
    tdSerializable          =   0x00002000,     // The class is Serializable.

    // Use tdStringFormatMask to retrieve string information for native interop
    tdStringFormatMask      =   0x00030000,
    tdAnsiClass             =   0x00000000,     // LPTSTR is interpreted as ANSI in this class
    tdUnicodeClass          =   0x00010000,     // LPTSTR is interpreted as UNICODE
    tdAutoClass             =   0x00020000,     // LPTSTR is interpreted automatically
    tdCustomFormatClass     =   0x00030000,     // A non-standard encoding specified by CustomFormatMask
    tdCustomFormatMask      =   0x00C00000,     // Use this mask to retrieve non-standard encoding information for native interop. The meaning of the values of these 2 bits is unspecified.

    // end string format mask

    tdBeforeFieldInit       =   0x00100000,     // Initialize the class any time before first static field access.
    tdForwarder             =   0x00200000,     // This ExportedType is a type forwarder.

    // Flags reserved for runtime use.
    tdReservedMask          =   0x00040800,
    tdRTSpecialName         =   0x00000800,     // Runtime should check name encoding.
    tdHasSecurity           =   0x00040000,     // Class has security associate with it.
} CorTypeAttr;

typedef struct _TYPEDEF_TABLE_ROW
{

   CorTypeAttr Flags <format=hex,comment="a 4-byte bitmask of type TypeAttributes">;
   if((sharpStream.HeapSizes & 0x01)==1)  // StringsIndexSize
   {
     DWORD TypeName <format=hex,comment="index into String heap">;
     DWORD TypeNamespace <format=hex,comment="index into String heap">;
   }
   else
   {
     WORD TypeName <format=hex,comment="index into String heap">;
     WORD TypeNamespace <format=hex,comment="index into String heap">;
   }

   WORD Extends <format=hex,comment="index into TypeDef, TypeRef or TypeSpec table; more precisely, a TypeDefOrRef coded index">;
   WORD FieldList <format=hex,comment="index into Field table; it marks the first of a continguous run of Fields owned by this Type">;
   WORD MethodList <format=hex,comment="index into MethodDef table">;
}TYPEDEF_TABLE_ROW;

///////////////////////////////////////////////////////////////////////////
// II.22.15
// Field : 0x04
///////////////////////////////////////////////////////////////////////////
typedef struct _FIELD_TABLE_ROW
{
   WORD Flags <format=hex,comment="a 2-byte bitmask of type ParamAttributes">;
   if((sharpStream.HeapSizes & 0x01)==1)  // StringsIndexSize
   {
      DWORD Name <format=hex,comment="an index into the String heap">;
   }
   else
   {
      WORD Name <format=hex,comment="an index into the String heap">;
   }
   if((sharpStream.HeapSizes & 0x04)==1)  // BlobIndexSize
      DWORD Signature <format=hex,comment="index into Blob heap">;
   else
      WORD Signature <format=hex,comment="index into Blob heap">;

}FIELD_TABLE_ROW;


///////////////////////////////////////////////////////////////////////////
// II.22.26
// MethodDef : 0x06
///////////////////////////////////////////////////////////////////////////
typedef enum <WORD> CorMethodImpl
{
    // code impl mask
    miCodeTypeMask      =   0x0003,   // Flags about code type.
    miIL                =   0x0000,   // Method impl is IL.
    miNative            =   0x0001,   // Method impl is native.
    miOPTIL             =   0x0002,   // Method impl is OPTIL
    miRuntime           =   0x0003,   // Method impl is provided by the runtime.
    // end code impl mask

    // managed mask
    miManagedMask       =   0x0004,   // Flags specifying whether the code is managed or unmanaged.
    miUnmanaged         =   0x0004,   // Method impl is unmanaged, otherwise managed.
    miManaged           =   0x0000,   // Method impl is managed.
    // end managed mask

    // implementation info and interop
    miForwardRef        =   0x0010,   // Indicates method is defined; used primarily in merge scenarios.
    miPreserveSig       =   0x0080,   // Indicates method sig is not to be mangled to do HRESULT conversion.

    miInternalCall      =   0x1000,   // Reserved for internal use.

    miSynchronized      =   0x0020,   // Method is single threaded through the body.
    miNoInlining        =   0x0008,   // Method may not be inlined.
    miMaxMethodImplVal  =   0xffff,   // Range check value
} CorMethodImpl;

typedef enum <WORD> CorMethodAttr
{
    // member access mask - Use this mask to retrieve accessibility information.
    mdMemberAccessMask          =   0x0007,
    mdPrivateScope              =   0x0000,     // Member not referenceable.
    mdPrivate                   =   0x0001,     // Accessible only by the parent type.
    mdFamANDAssem               =   0x0002,     // Accessible by sub-types only in this Assembly.
    mdAssem                     =   0x0003,     // Accessibly by anyone in the Assembly.
    mdFamily                    =   0x0004,     // Accessible only by type and sub-types.
    mdFamORAssem                =   0x0005,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    mdPublic                    =   0x0006,     // Accessibly by anyone who has visibility to this scope.
    // end member access mask

    // method contract attributes.
    mdStatic                    =   0x0010,     // Defined on type, else per instance.
    mdFinal                     =   0x0020,     // Method may not be overridden.
    mdVirtual                   =   0x0040,     // Method virtual.
    mdHideBySig                 =   0x0080,     // Method hides by name+sig, else just by name.

    // vtable layout mask - Use this mask to retrieve vtable attributes.
    mdVtableLayoutMask          =   0x0100,
    mdReuseSlot                 =   0x0000,     // The default.
    mdNewSlot                   =   0x0100,     // Method always gets a new slot in the vtable.
    // end vtable layout mask

    // method implementation attributes.
    mdCheckAccessOnOverride     =   0x0200,     // Overridability is the same as the visibility.
    mdAbstract                  =   0x0400,     // Method does not provide an implementation.
    mdSpecialName               =   0x0800,     // Method is special. Name describes how.

    // interop attributes
    mdPinvokeImpl               =   0x2000,     // Implementation is forwarded through pinvoke.
    mdUnmanagedExport           =   0x0008,     // Managed method exported via thunk to unmanaged code.

    // Reserved flags for runtime use only.
    mdReservedMask              =   0xd000,
    mdRTSpecialName             =   0x1000,     // Runtime should check name encoding.
    mdHasSecurity               =   0x4000,     // Method has security associate with it.
    mdRequireSecObject          =   0x8000,     // Method calls another method containing security code.

} CorMethodAttr;

typedef struct _METHODDEF_TABLE_ROW
{
   DWORD RVA <format=hex,comment="a 4-byte constant">;
   CorMethodImpl ImplFlags <comment="a 2-byte bitmask of type MethodImplAttributes">;
   CorMethodAttr Flags <format=hex,comment="a 2-byte bitmask of type MethodAttribute">;
   if((sharpStream.HeapSizes & 0x01)==1)  // StringsIndexSize
      DWORD Name <format=hex,comment="index into String heap">;
   else
      WORD Name <format=hex,comment="index into String heap">;
   if((sharpStream.HeapSizes & 0x04)==1)  // BlobIndexSize
      DWORD Signature <format=hex,comment="index into Blob heap">;
   else
      WORD Signature <format=hex,comment="index into Blob heap">;
   WORD ParamList <format=hex,comment="index into Param table">;
}METHODDEF_TABLE_ROW;

///////////////////////////////////////////////////////////////////////////
// II.22.33
// TypeRef : 0x08
///////////////////////////////////////////////////////////////////////////
typedef struct _PARAM_TABLE_ROW
{
   WORD Flags <format=hex,comment="a 2-byte bitmask of type ParamAttributes">;
   WORD TypeNamespace <format=hex,comment="a 2-byte constant">;
   if((sharpStream.HeapSizes & 0x01)==1)  // StringsIndexSize
   {
      DWORD Name <format=hex,comment="an index into the String heap">;
   }
   else
   {
      WORD Name <format=hex,comment="an index into the String heap">;
   }
}PARAM_TABLE_ROW;

///////////////////////////////////////////////////////////////////////////
// II.22.25
// MemberRef : 0x0A
///////////////////////////////////////////////////////////////////////////
typedef struct _MEMBERREF_TABLE_ROW
{
   WORD Class <format=hex,comment="index into the TypeRef, ModuleRef, MethodDef, TypeSpec or TypeDef tables; more precisely, a MemberRefParent coded index">;
   if((sharpStream.HeapSizes & 0x01)==1)  // StringsIndexSize
      DWORD Name <format=hex,comment="index into String heap">;
   else
      WORD Name <format=hex,comment="index into String heap">;
   if((sharpStream.HeapSizes & 0x04)==1)  // BlobIndexSize
      DWORD Signature <format=hex,comment="index into Blob heap">;
   else
      WORD Signature <format=hex,comment="index into Blob heap">;
} MEMBERREF_TABLE_ROW;

///////////////////////////////////////////////////////////////////////////
// II.22.25
// CustomAttribute : 0x0C
///////////////////////////////////////////////////////////////////////////
typedef struct _CUSTOMATTRIBUTE_TABLE_ROW
{
   WORD Parent <format=hex,comment="an index into a metadata table that has an associated HasCustomAttribute">;
   WORD Type <format=hex,comment="an index into the MethodDef or MemberRef table; more precisely, a CustomAttributeType">;
   if((sharpStream.HeapSizes & 0x04)==1)  // BlobIndexSize
      DWORD Value <format=hex,comment="index into Blob heap">;
   else
      WORD Value <format=hex,comment="index into Blob heap">;
} CUSTOMATTRIBUTE_TABLE_ROW;

///////////////////////////////////////////////////////////////////////////
// II.22.2
// Assembly : 0x20
///////////////////////////////////////////////////////////////////////////
typedef enum <DWORD> CorAssemblyFlags
{
    afPublicKey             =   0x0001,     // The assembly ref holds the full (unhashed) public key.
   
    afPA_None               =   0x0000,     // Processor Architecture unspecified
    afPA_MSIL               =   0x0010,     // Processor Architecture: neutral (PE32)
    afPA_x86                =   0x0020,     // Processor Architecture: x86 (PE32)
    afPA_IA64               =   0x0030,     // Processor Architecture: Itanium (PE32+)
    afPA_AMD64              =   0x0040,     // Processor Architecture: AMD X64 (PE32+)
    afPA_Specified          =   0x0080,     // Propagate PA flags to AssemblyRef record
    afPA_Mask               =   0x0070,     // Bits describing the processor architecture
    afPA_FullMask           =   0x00F0,     // Bits describing the PA incl. Specified
    afPA_Shift              =   0x0004,     // NOT A FLAG, shift count in PA flags <--> index conversion

    afEnableJITcompileTracking  =   0x8000, // From "DebuggableAttribute".
    afDisableJITcompileOptimizer=   0x4000, // From "DebuggableAttribute".

    afRetargetable          =   0x0100,     // The assembly can be retargeted (at runtime) to an
                                            // assembly from a different publisher.
} CorAssemblyFlags;

typedef struct _ASSEMBLY_TABLE_ROW
{
   DWORD HashAlgId <format=hex,comment="a 4-byte constant of type AssemblyHashAlgorithm">;
   WORD MajorVersion; 
   WORD MinorVersion; 
   WORD BuildNumber; 
   WORD RevisionNumber; 
   CorAssemblyFlags Flags <format=hex,comment="a 4-byte bitmask of type AssemblyFlags">;
   if((sharpStream.HeapSizes & 0x04)==1)  // BlobIndexSize
      DWORD PublicKey <format=hex,comment="index into Blob heap">;
   else
      WORD PublicKey <format=hex,comment="index into Blob heap">;
   if((sharpStream.HeapSizes & 0x01)==1)  // StringsIndexSize
   {
      DWORD Name <format=hex,comment="index into String heap">;
      DWORD Culture <format=hex,comment="index into String heap">;   
   }
   else
   {
      WORD Name <format=hex,comment="index into String heap">;
      WORD Culture <format=hex,comment="index into String heap">;   
   }
}ASSEMBLY_TABLE_ROW;

///////////////////////////////////////////////////////////////////////////
// II.22.5
// AssemblyRef : 0x23
///////////////////////////////////////////////////////////////////////////
typedef struct _ASSEMBLYREF_TABLE_ROW
{
   WORD MajorVersion; 
   WORD MinorVersion; 
   WORD BuildNumber; 
   WORD RevisionNumber; 
   CorAssemblyFlags Flags <format=hex,comment="a 4-byte bitmask of type AssemblyFlags">;
   if((sharpStream.HeapSizes & 0x04)==1)  // BlobIndexSize
      DWORD PublicKey <format=hex,comment="index into Blob heap">;
   else
      WORD PublicKey <format=hex,comment="index into Blob heap">;
   if((sharpStream.HeapSizes & 0x01)==1)  // StringsIndexSize
   {
      DWORD Name <format=hex,comment="index into String heap">;
      DWORD Culture <format=hex,comment="index into String heap">;   
   }
   else
   {
      WORD Name <format=hex,comment="index into String heap">;
      WORD Culture <format=hex,comment="index into String heap">;   
   }
   if((sharpStream.HeapSizes & 0x04)==1)  // BlobIndexSize
      DWORD HashValue <format=hex,comment="index into Blob heap">;
   else
      WORD HashValue <format=hex,comment="index into Blob heap">;

}ASSEMBLYREF_TABLE_ROW;

//----------------------------------------------------------------------------
void ParseCLIHeader()
{
    if( (NtHeader.OptionalHeader.DataDirArray.DataDir14.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.DataDir14.Size == 0) )
    {
       return;
    }
    FSeek( RVA2FOA(NtHeader.OptionalHeader.DataDirArray.DataDir14.VirtualAddress) );

    SECTION_CLI_HEADER CliHeader;
    
    Printf("File offset for MetaData Root HEADER at %x\n",RVA2FOA(CliHeader.MetaDataRVA));

    FSeek(RVA2FOA(CliHeader.MetaDataRVA) );
    PHYSICAL_METADATA_HEADER metadata;

    if (0x424A5342 != metadata.Signature)
    {
      Printf("invalid metadata Signature 0x%x \n",metadata.Signature);
      return;
    }
    
    STREAM_HEADER  streams[metadata.Streams] <optimize=false, fgcolor=cRed, bgcolor=0xFFFFCC, comment="Metadata stream header">;

    local BYTE ILBuffer[1024];
    local int ILSize;
    local int i,ii,k;
    for (i=0; i < metadata.Streams; i++)
    {
      if ("#~" == streams[i].Name)
      {
        //Printf("Stream #~  0x%x \n",RVA2FOA(CliHeader.MetaDataRVA) + streams[i].Offset);
        FSeek(RVA2FOA(CliHeader.MetaDataRVA) + streams[i].Offset);
        SHARP_STREAM sharpStream;

        DWORD TableRowSize[ComputeValidTableNumber()];

    
        local int index = 0;
        if(isValidTable(enumModule))
        {
           Printf("*** enumModule table (%d) size=%d ***\n",index,TableRowSize[index]);
           for (ii=0; ii < TableRowSize[index]; ii++)
           {
              MODULE_TABLE_ROW moduletable <optimize=false>;
              Printf("\tModule name = '%s'\n", ReadString(RVA2FOA(CliHeader.MetaDataRVA) + streams[1].Offset + moduletable[ii].Name)); // streams[1].Offset => string stream start addr
           }
           index++;

        }
        if(isValidTable(enumTypeRef))
        {
          Printf("*** enumTypeRef table (%d) size=%d ***\n",index,TableRowSize[index]);
           for (ii=0; ii < TableRowSize[index]; ii++)
           {
              TYPEREF_TABLE_ROW typereftable <optimize=false>;
              Printf("\tTypeRef name = '%s::%s'\n", ReadString(RVA2FOA(CliHeader.MetaDataRVA) + streams[1].Offset + typereftable[ii].TypeNamespace),ReadString(RVA2FOA(CliHeader.MetaDataRVA) + streams[1].Offset + typereftable[ii].TypeName)); // streams[1].Offset => string stream start addr
           }
          index++;
        }
        if(isValidTable(enumTypeDef))
        {
           Printf("*** enumTypeDef table (%d) size=%d ***\n",index,TableRowSize[index]);
           for (ii=0; ii < TableRowSize[index]; ii++)
           {
              TYPEDEF_TABLE_ROW typedeftable <optimize=false>;
              Printf("\tTypeDef name = '%s::%s'\n", ReadString(RVA2FOA(CliHeader.MetaDataRVA) + streams[1].Offset + typedeftable[ii].TypeNamespace),ReadString(RVA2FOA(CliHeader.MetaDataRVA) + streams[1].Offset + typedeftable[ii].TypeName)); // streams[1].Offset => string stream start addr

           }
          index++;
        }

        // Reserved1 = 8,  table 3

        if(isValidTable(enumField))
        {
           Printf("*** enumField table (%d) size=%d ***\n",index,TableRowSize[index]);
           for (ii=0; ii < TableRowSize[index]; ii++)
           {
              FIELD_TABLE_ROW fieldtable <optimize=false>;
              Printf("\tField name = '%s'\n", ReadString(RVA2FOA(CliHeader.MetaDataRVA) + streams[1].Offset + fieldtable[ii].Name)); // streams[1].Offset => string stream start addr

           }
          index++;
        }

        // Reserved2 = 32, table 5

        if(isValidTable(enumMethod))
        {
          Printf("*** enumMethod table (%d) size=%d ***\n",index,TableRowSize[index]);
           for (ii=0; ii < TableRowSize[index]; ii++)
           {
              METHODDEF_TABLE_ROW methoddeftable <optimize=false>;              
              Printf("\tMethod name = '%s' RVA %x\n", ReadString(RVA2FOA(CliHeader.MetaDataRVA) + streams[1].Offset + methoddeftable[ii].Name),methoddeftable[ii].RVA); 

              // II.25.4 Common Intermediat e Language physical layout
              if((methoddeftable[ii].RVA - NtHeader.OptionalHeader.SectionAlignment + NtHeader.OptionalHeader.FileAlignment) < FileSize())
              {
                ReadBytes(ILBuffer, (methoddeftable[ii].RVA - NtHeader.OptionalHeader.SectionAlignment + NtHeader.OptionalHeader.FileAlignment),1);
                switch(ILBuffer[0] & 0x03) {
                   case 0x2:  // CorILMethod_FatFormat            
                      ILSize = (ILBuffer[0] >> 2) & 0x3F; // only 6 bits 11 1111b
                      Printf("\t CIL: [CorILMethod_TinyFormat => size=%02x] ",ILSize); // 00000011b
                      break;
                   case 0x3:  // CorILMethod_TinyFormat

                   //   local FAT_FORMAT methodbodyfatFormat;
                   //   ReadBytes(methodbodyfatFormat, (methoddeftable[ii].RVA - NtHeader.OptionalHeader.SectionAlignment + NtHeader.OptionalHeader.FileAlignment),sizeof(FAT_FORMAT));

                   // switch(methodbodyfatFormat.Flags_Size & 0x18) { //  0001 1000b
                   //    case 0x8:
                   //        Printf("\t{CorILMethod_MoreSects so More sections follow after this header TODO!!!}\n");
                   //        break;  
                   //    case 0x10:
                   //        Printf("\t{Call default constructor on all local variables.}\n");
                   //        break;                       
                   // }
                   // ILSize = methodbodyfatFormat.CodeSize;
                   // Printf("\t CIL: [CorILMethod_FatFormat => {0x%02x} size=%02x] ",methodbodyfatFormat.Flags_Size, ILSize); // 00000011b
                      Printf("\t CIL: [CorILMethod_FatFormat] TODO ==> ");
                      ILSize = 16;
                      break;
                } 
  
                ReadBytes(ILBuffer, (methoddeftable[ii].RVA - NtHeader.OptionalHeader.SectionAlignment + NtHeader.OptionalHeader.FileAlignment), ILSize+1);
 
                for (k=1; k <= ILSize; k++)
                  Printf("%02X ", ILBuffer[k] & 0xFF);
                Printf("\n");
              } else
                Printf("RVA out of image!!!\n");
           }
          index++;
        }

        // Reserved3 = 128,	 table 7
 
        if(isValidTable(enumParam))
        {
          Printf("*** enumParam table (%d) size=%d ***\n",index,TableRowSize[index]);
           for (ii=0; ii < TableRowSize[index]; ii++)
           {
              PARAM_TABLE_ROW paramtable <optimize=false>;
              Printf("\param name = '%s'\n", ReadString(RVA2FOA(CliHeader.MetaDataRVA) + streams[1].Offset + paramtable[ii].Name)); 
           }
           index++;
        }
 
        if(isValidTable(enumInterfaceImpl))
        {
          Printf("*** enumInterfaceImpl table (%d) size=%d ***\n",index,TableRowSize[index]);
        }
        if(isValidTable(enumMemberRef))
        {
          Printf("*** enumMemberRef table (%d) size=%d ***\n",index,TableRowSize[index]);
           for (ii=0; ii < TableRowSize[index]; ii++)
           {
              MEMBERREF_TABLE_ROW memberreftable <optimize=false>;
              Printf("\tMemberRef name = <%s>\n", ReadString(RVA2FOA(CliHeader.MetaDataRVA) + streams[1].Offset + memberreftable[ii].Name)); // streams[1].Offset => string stream start addr              
           }
          index++;
        }

        if(isValidTable(enumConstant))
        {
          Printf("*** enumConstant table (%d) size=%d ***\n",index,TableRowSize[index]);
        }
        if(isValidTable(enumCustomAttribute))
        {
          Printf("*** enumCustomAttribute table (%d) size=%d ***\n",index,TableRowSize[index]);
           for (ii=0; ii < TableRowSize[index]; ii++)
           {
              CUSTOMATTRIBUTE_TABLE_ROW memberreftable <optimize=false>;
           }
          index++;
        }
        if(isValidTable(enumFieldMarshal))
        {
          Printf("*** enumFieldMarshal table (%d) size=%d ***\n",index,TableRowSize[index]);
        }
        if(isValidTable(enumDeclSecurity))
        {
          Printf("*** enumDeclSecurity table (%d) size=%d ***\n",index,TableRowSize[index]);
        }        
        if(isValidTable(enumClassLayout))
        {
          Printf("*** enumClassLayout table (%d) size=%d ***\n",index,TableRowSize[index]);
        }        
        if(isValidTable(enumFieldLayout))
        {
          Printf("*** enumFieldLayout table (%d) size=%d ***\n",index,TableRowSize[index]);
        }        
        if(isValidTable(enumStandAloneSig))
        {
           Printf("===> enumStandAloneSig table\n");
        }        
        if(isValidTable(enumEventMap))
        {
           Printf("===> enumEventMap table\n");
        }
    
        // Reserved4 = 524288,	table 19
 
        if(isValidTable(enumEvent))
        {
           Printf("===> enumEvent table\n");
        }
        if(isValidTable(enumPropertyMap))
        {
           Printf("===> enumPropertyMap table\n");
        }
       
        //    Reserved5 = 4194304, table 22

        if(isValidTable(enumProperty))
        {
           Printf("===> enumProperty table\n");
        }
        if(isValidTable(enumMethodSemantics))
        {
           Printf("===> enumMethodSemantics table\n");
        }
        if(isValidTable(enumMethodImpl))
        {
           Printf("===> enumMethodImpl table\n");
        }
        if(isValidTable(enumModuleRef))
        {
           Printf("===> enumModuleRef table\n");
        }
        if(isValidTable(enumTypeSpec))
        {
           Printf("===> enumTypeSpec table\n");
        }
        if(isValidTable(enumImplMap))
        {
           Printf("===> enumImplMap table\n");
        }
        if(isValidTable(enumFieldRVA))
        {
           Printf("===> enumFieldRVA table\n");
        }
 
        // Reserved6 = 1073741824,	table 30
        // Reserved7 = 2147483648,	table 31

        if(isValidTable(enumAssembly))
        {
          Printf("*** enumAssembly table (%d) size=%d ***\n",index,TableRowSize[index]);
           for (ii=0; ii < TableRowSize[index]; ii++)
           {
              ASSEMBLY_TABLE_ROW assemblytable <optimize=false>;
              Printf("\tMemberRef name = <%s>\n", ReadString(RVA2FOA(CliHeader.MetaDataRVA) + streams[1].Offset + assemblytable[ii].Name)); // streams[1].Offset => string stream start addr
           }
          index++;
        }
        if(isValidTable(enumAssemblyProcessor))
        {
           Printf("===> enumAssemblyProcessor table\n");
        }
        if(isValidTable(enumAssemblyOS))
        {
           Printf("===> enumAssemblyOS table\n");
        }

        if(isValidTable(enumAssemblyRef))
        {
          Printf("*** enumAssemblyRef table (%d) size=%d ***\n",index,TableRowSize[index]);
            for (ii=0; ii < TableRowSize[index]; ii++)
           {
              ASSEMBLYREF_TABLE_ROW assemblyreftable <optimize=false>;
              Printf("\tMemberRef name = <%s>\n", ReadString(RVA2FOA(CliHeader.MetaDataRVA) + streams[1].Offset + assemblyreftable[ii].Name)); // streams[1].Offset => string stream start addr
           }
          index++;        
        }

        if(isValidTable(enumAssemblyRefProcessor))
        {
           Printf("===> enumAssemblyRefProcessor table\n");
        }
        if(isValidTable(enumAssemblyRefOS))
        {
           Printf("===> enumAssemblyRefOS table\n");
        }
        if(isValidTable(enumFile))
        {
           Printf("===> enumFile table\n");
        }
        if(isValidTable(enumExportedType))
        {
           Printf("===> enumExportedType table\n");
        }
        if(isValidTable(enumManifestResource))
        {
           Printf("===> enumManifestResource table\n");
        }
        if(isValidTable(enumNestedClass))
        {
           Printf("===> enumNestedClass table\n");
        }
        if(isValidTable(enumGenericParam))
        {
           Printf("===> enumGenericParam table\n");
        }
        if(isValidTable(enumMethodSpec))
        {
           Printf("===> enumMethodSpec table\n");
        }
        if(isValidTable(enumGenericParamConstraint))
        {
           Printf("===> enumGenericParamConstraint table\n");
        }

      } 
      else if ("#Strings" == streams[i].Name)
      {
        //Printf("Stream #Strings 0x%x \n",RVA2FOA(CliHeader.MetaDataRVA) + streams[i].Offset);
        FSeek(RVA2FOA(CliHeader.MetaDataRVA) + streams[i].Offset);
        char stringsStream[streams[i].Size] <fgcolor=cRed, bgcolor=0xFFFFCC, comment="strings stream">;
      }
      else if ("#US" == streams[i].Name)
      {
        //Printf("Stream #US 0x%x \n",RVA2FOA(CliHeader.MetaDataRVA) + streams[i].Offset);
        FSeek(RVA2FOA(CliHeader.MetaDataRVA) + streams[i].Offset);
        BYTE stringsuserStream[streams[i].Size] <fgcolor=cRed, bgcolor=0xFFFFCC, comment="strings stream">;
      }
      else if ("#GUID" == streams[i].Name)
      {
        //Printf("Stream #GUID 0x%x \n",RVA2FOA(CliHeader.MetaDataRVA) + streams[i].Offset);
        FSeek(RVA2FOA(CliHeader.MetaDataRVA) + streams[i].Offset);
        BYTE GUIDStream[streams[i].Size] <optimize=false, fgcolor=cRed, bgcolor=0xFFFFCC, comment=FormatGUID >; 
        FSeek(RVA2FOA(CliHeader.MetaDataRVA) + streams[i].Offset);


        Printf("GUID=%s\n",FormatGUID(0));
      }
      else if ("#Blob" == streams[i].Name)
      {
        //Printf("Stream #Blob 0x%x \n",RVA2FOA(CliHeader.MetaDataRVA) + streams[i].Offset);
        FSeek(RVA2FOA(CliHeader.MetaDataRVA) + streams[i].Offset);
        BYTE blobStream[streams[i].Size];
      }
    }

}

//--------------------------------------------------------------------------------------------------------
// Main Code
Printf("Parse PE Begin.\n");
IMAGE_DOS_HEADER DosHeader;
if (DosHeader.e_magic != 0x5A4D)
{
    Printf("invalid dos magic.\n");
    return 1;
}
if (0 == DosHeader.e_lfanew )
{
    Warning("not invalid e_lfanew = 0x%X",DosHeader.e_lfanew);
    return 2;
}

UCHAR Space1[DosHeader.e_lfanew - sizeof(IMAGE_DOS_HEADER)] <hidden=true,fgcolor=cRed,comment="Space between dos header and nt header">;
Printf("Space between dos header and nt header is %d bytes \n",DosHeader.e_lfanew - sizeof(IMAGE_DOS_HEADER));
FSeek(DosHeader.e_lfanew);

IMAGE_NT_HEADERS NtHeader;
if (0x00004550 != NtHeader.Signature)
{
    Printf("invalid nt Signature 0x%x \n",NtHeader.Signature);
    return 3;
}

IMAGE_SECTION_HEADER SectionHeaders[NtHeader.FileHeader.NumberOfSections];

//no align header size
local ULONG ulRawHeaderSize = DosHeader.e_lfanew + sizeof(NtHeader) + NtHeader.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER);

if (NtHeader.OptionalHeader.SizeOfHeaders - ulRawHeaderSize >0)
{
    UCHAR Space2[NtHeader.OptionalHeader.SizeOfHeaders  - ulRawHeaderSize ] <hidden=true,fgcolor=cRed,comment="Space between header and first section">;
}
Printf("Space between headers and first sections is %d bytes\n",NtHeader.OptionalHeader.SizeOfHeaders  - ulRawHeaderSize);

FSeek(NtHeader.OptionalHeader.SizeOfHeaders);

local ULONG ulIndex=0;
for (ulIndex=0; ulIndex < NtHeader.FileHeader.NumberOfSections; ulIndex++)
{
    if ( 0 == SectionHeaders[ulIndex].PointerToRawData )
    {
        continue;
    }
    if ( 0 == SectionHeaders[ulIndex].SizeOfRawData )
    {
        continue;
    }
    IMAGE_SECTION_DATA    Section(SectionHeaders[ulIndex]);
}

FSeek(NtHeader.OptionalHeader.SizeOfHeaders);

//Parse Directory
ParseEAT();
ParseIAT();
ParseResource();
ParseException();
ParseSecurity();
ParseBaseReloc();
ParseDebug();
ParseTLS();
ParseBoundImport();
ParseDelayImport();
ParseCLIHeader();

Printf("Parse PE finish.\n");
